{"./":{"url":"./","title":"序言","keywords":"","body":"编程基础复盘笔记 本系列是 coding_basis_review 更多的学习笔记请参考： Golang 学习笔记 编程基础复盘 编程人生 个人博客：hanyajun.com 目录 序言 网络基础 网络基础TCP/IP HTTP和HTTPS 工具 git操作整理 赞赏 如果觉得文章有帮助的话，可以打赏一下，非常感谢 Copyright © hanyajun.com all right reserved，powered by GitbookUpdated at 2019-06-21 00:49:17 "},"network/summary.html":{"url":"network/summary.html","title":"网络基础","keywords":"","body":"网络基础 网络基础TCP/IP HTTP和HTTPS Copyright © hanyajun.com all right reserved，powered by GitbookUpdated at 2019-06-21 01:02:32 "},"network/TCP_IP.html":{"url":"network/TCP_IP.html","title":"网络基础TCP/IP","keywords":"","body":"网络基础 TCP / IP 　　通常使用的网络（包括互联网）是在 TCP / IP 协议族的基础上运作的，而 HTTP 属于它内部的一个子集。Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端（指通过发送请求获取服务器资源的 Web 浏览器等）到服务器端等一系列运作流程，而协议是指规则的约定。可以说，Web 是建立在 HTTP 协议上通信的。 协议 　　计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则，而我们就把这种规则称为协议。 TCP / IP 协议族 像这样把与互联网相关联的协议集合起来总称为 TCP / IP，如 HTTP、FTP、DNS、TCP 都为 TCP / IP 协议集合下的协议。 OSI与TCP/IP分层模型 　　TCP / IP 协议族里最重要的一点就是分层，分层的好处是只需把各层之间的接口部分规划好，每个层次的内部设计就能自由改动，而不会影响到整体。TCP / IP 协议族按层次分别为以下四层： 应用层，决定了向用户提供应用服务时通信的活动。 TCP / IP 协议族内预存了各类通用的应用服务，比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类，HTTP 协议也处于该层； 传输层，对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。 在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）； 网络层（又名网络互连层），用来处理在网络上流动的数据包。 数据包是网络传输的最小数据单位，该层规定了通过怎样的路径（所谓的传输路线）到达对象计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层起的作用就是在众多的选项内选择一条传输路线； 数据链路层（又名数据链路层，网络接口层），用来处理连接网络的硬件部分. 包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。 TCP / IP 通信传输流 　　利用 TCP / IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。举例用 HTTP 来说明： 首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求； 接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层； 在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层； 这样一来，发往网络的通信请求就准备齐全了。接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。 　　发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装（encapsulate）。 OSI参考模型分层说明 OSI参考模型通信过程 1、打包数据时，每一层在处理上一层传过来的数据时，会在数据上附上当前层的首部信息后传给下一层； 2、解包数据时，每一层在处理下一层传过来的数据时，会将当前层的首部信息与数据分开，将数据传给上一层。 3、数据通信过程: 分层 每层的操作 应用层 在数据前面加首部，首部包括数据内容、源地址和目标地址，同时也会处理异常的反馈信息。 表示层 将特有的数据格式转换为通用的数据格式，同时也会加上表示层的首部信息以供解析。 会话层 对何时连接，以何种方式连接，连接多久，何时断开等做记录。同时也会加会话层的首部信息。 传输层 建立连接，断开连接，确认数据是否发送成功和执行失败重发任务。 网络层 负责将数据发到目标地址，也包含首部信息。 数据链路层 通过物理的传输介质实现数据的传输。 物理层 将0/1转换成物理的传输介质，通过MAC地址进行传输。 与 HTTP 关系密切的协议 : IP、TCP 和 DNS 负责传输的 IP 协议，通过 IP 地址和 MAC 地址将数据送往对方。 按层次分，IP（Internet Protocol）网际协议位于网络层。TCP / IP 协议族中的 IP 指的是网际协议，是一种协议的名称。IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。在网络上，通信的双方通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol），一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线，这种机制称为路由选择（routing）； 确保可靠性的 TCP 协议，使用了三次握手策略确保数据发送成功。 按层次分，TCP 位于传输层，提供可靠的字节流服务。所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。即 TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议采用三次握手策略。 简单示意图： 客户端–发送带有 SYN 标志的数据包–一次握手–服务端 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端 四次挥手 断开一个 TCP 连接则需要“四次挥手”： 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号 服务器-关闭与客户端的连接，发送一个FIN给客户端 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1 负责域名解析的 DNS 服务，提供域名到 IP 地址之间的解析服务。 DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议，它提供域名到 IP 地址之间的解析服务。计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。用户通常使用主机名或域名来访问对方的计算机，DNS 协议提供通过域名查找 IP 地址，发送给计算机的是 IP 地址。计算机可通过 DNS 协议的逆向从 IP 地址反查域名。 概括下请求响应的流程： 客户端发起请求，想访问某个主机名或域名； DNS 协议对主机名或域名进行解析，得到 IP 地址； HTTP 协议将请求报文分割成多个报文段来发送； IP 协议通过 IP 地址和 MAC 地址将数据送往对方； TCP 协议使用三次握手策略确保数据发送成功，按序号以原来的顺序重组请求报文； 服务端获得请求报文，进行处理，处理结果同样使用 TCP / IP 协议进行回传。 URI 和 URL 　　URL（Uniform Resource Locator，统一资源定位符），使用 Web 浏览器等访问 Web 页面时需要输入的网页地址，比如 https://www.google.com/ 。URI 是 Uniform Resource Identifier 的缩写，这三个单词分别表示： Uniform，规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如 http: 或 ftp:）也更容易； Resource，资源的定义是“可标识的任何东西”。除了文档文件、图像或服务（例如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体； Identifier，表示可标识的对象。也称为标识符； 　　综上所述，URI 就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。采用 HTTP 协议时，协议方案就是 http。URI 用字符串标识某一互联网资源，而 URL表示资源的地点（互联网上所处的位置），可见 URL是 URI 的子集。 绝对URI 格式 　　以 “http://user:pass@www.example.jp:80/dir/index.html?uid=1#ch1” 为例： \"http://\" ，协议方案名。使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）。也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名； \"user:pass\" ，登录信息（认证）。指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证），此项是可选项； \"www.example.jp\" ，服务器地址。使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似 hackr.jp 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名； \"80\"，服务器端口号。指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号； \"dir/index.html\"，带层次的文件路径。指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似； \"uid=1\"，查询字符串。针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数，此项可选； \"ch1\"，使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 RFC 中并没有明确规定其使用方法，该项也为可选项。 常见的面试题 TCP三次握手 为什么要三次握手？ 三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常 所以三次握手就能确认双发收发功能都正常，缺一不可。、 为什么要传回 SYN? 接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。 SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。 为什么TCP客户端最后还要发送一次确认呢？ 一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。 如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。四次挥手 为什么要四次挥手? 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。 举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。 为什么客户端最后还要等待2MSL？ MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。 第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。 第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。 为什么建立连接是三次握手，关闭连接确是四次挥手呢？ 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。 参考文章： 《图解http》 https://blog.csdn.net/qzcsu/article/details/72861891 Copyright © hanyajun.com all right reserved，powered by GitbookUpdated at 2019-06-30 17:46:02 "},"network/HTTP_HTTPS.html":{"url":"network/HTTP_HTTPS.html","title":"HTTP和HTTPS","keywords":"","body":"HTTP和HTTPS详解 计算机通信原理 互联网的关键技术就是TCP/IP协议。两台计算机之间的通信是通过TCP/IP协议在因特网上进行的。实际上这个是两个协议： TCP: Transmission Control Protocol 传输控制协议 IP: Internet Protocol 网际协议。 引自维基百科TCP/IP协议族是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。这个协议族由互联网工程任务组负责维护。 TCP: 应用程序之间的通信 TCP确保数据包以正确的次序到达，并且尝试确认数据包的内容没有改变。TCP在IP地址之上引端口（port），它允许计算机通过网络提供各种服务。一些端口号为不同的服务保留，而且这些端口号是众所周知。 服务或者守护进程：在提供服务的机器上，有程序监听特定端口上的通信流。例如大多数电子邮件通信流出现在端口25上，用于wwww的HTTP通信流出现在80端口上。 当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信，占用两个计算机之间整个的通信线路。TCP 用于从应用程序到网络的数据传输控制。TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。 TCP/IP 就是TCP 和 IP 两个协议在一起协同工作，有上下层次的关系。 TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。IP 负责计算机之间的通信。TCP 负责将数据分割并装入 IP 包，IP 负责将包发送至接受者，传输过程要经IP路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址，然后在它们到达的时候重新组合它们。 IP: 计算机之间的通信 IP协议是计算机用来相互识别的通信的一种机制，每台计算机都有一个IP.用来在internet上标识这台计算机。 IP 负责在因特网上发送和接收数据包。通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。IP 负责将每个包路由至它的目的地。 IP协议仅仅是允许计算机相互发消息，但它并不检查消息是否以发送的次序到达而且没有损坏（只检查关键的头数据）。为了提供消息检验功能，直接在IP协议上设计了传输控制协议TCP。 HTTP HTTP概念 引自维基百科HTTP:超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。 设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。 HTTP协议层 HTTP（HyperText Transfer Protocol），超文本传输协议，是一个基于TCP实现的应用层协议。 HTTP请求响应模型 HTTP由请求和响应构成，是一个标准的客户端服务器模型（B/S）。HTTP协议永远都是客户端发起请求，服务器回送响应。见下图: HTTP是一个无状态的协议。无状态是指客户机（Web浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP遵循请求(Request)/应答(Response)模型。客户机（浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。所有HTTP连接都被构造成一套请求和应答。 HTTP工作过程 一次HTTP操作称为一个事务，其工作整个过程如下： 地址解析 如用客户端浏览器请求这个页面：localhost.com:8080/index.htm 从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下： 协议名：http 主机名：localhost.com 端口：8080 对象路径：/index.htm 在这一步，需要域名系统DNS解析域名localhost.com,得主机的IP地址。 封装HTTP请求数据包 把以上部分结合本机自己的信息，封装成一个HTTP请求数据包 封装成TCP包，建立TCP连接（TCP的三次握手） 在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。这里是8080端口。 客户机发送请求命令 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容。 服务器响应 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据 服务器关闭TCP连接 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 HTTP工作过程用到的概念 报文格式 HTTP1.0的报文有两种类型：请求和响应。其报文格式分别为： 请求报文格式 请求方法 URL HTTP/版本号 请求首部字段(可选) 空行 body(只对Post请求有效) 例如： GET http://m.baidu.com/ HTTP/1.1 Host m.baidu.com Connection Keep-Alive ...// 其他header key=iOS 响应报文格式 HTTP/版本号 返回码 返回码描述 应答首部字段(可选) 空行 body 例如： HTTP/1.1 200 OK Content-Type text/html;charset=UTF-8 ...// 其他header ... URL的结构 使用HTTP协议访问资源是通过URL（Uniform Resource Locator）统一资源定位符来实现的。URL的格式如下： scheme://host:port/path?query scheme: 表示协议，如Http, Https, Ftp等； host: 表示所访问资源所在的主机名：如：www.baidu.com; port: 表示端口号，默认为80； path: 表示所访问的资源在目标主机上的储存路径； query: 表示查询条件； 例如： http://www.baidu.com/search?words=Baidu HTTP的请求方法 GET: 获取URL指定的资源； POST：传输实体信息 PUT：上传文件 DELETE：删除文件 HEAD：获取报文首部，与GET相比，不返回报文主体部分 OPTIONS：询问支持的方法 TRACE：追踪请求的路径； CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信。主要使用SSL和TLS将数据加密后通过网络隧道进行传输。 复制代码 报文字段 HTTP首部字段由字段名和字段值组成，中间以\":\"分隔，如Content-Type: text/html.其中，同一个字段名可对应多个字段值。 HTTP的报文字段分为5种： 请求报文字段 应答报文字段 实体首部字段 通用报文字段 其他报文字段 请求报文字段 HTTP请求中支持的报文字段。 Accept：客户端能够处理的媒体类型。如text/html, 表示客户端让服务器返回html类型的数据，如果没有，返回text 类型的也可以。媒体类型的格式一般为：type/subType, 表示优先请求subType类型的数据，如果没有，返回type类型 数据也可以。 常见的媒体类型： 文本文件：text/html, text/plain, text/css, application/xml 图片文件：iamge/jpeg, image/gif, image/png; 视频文件：video/mpeg 应用程序使用的二进制文件：application/octet-stream, application/zip Accept字段可设置多个字段值，这样服务器依次进行匹配，并返回最先匹配到的媒体类型，当然，也可通过q参数来设置 媒体类型的权重，权重越高，优先级越高。q的取值为[0, 1], 可取小数点后3位，默认为1.0。例如： Accept: text/html, application/xml; q=0.9, */* Accept-Charset: 表示客户端支持的字符集。例如：Accept-Charset: GB2312, ISO-8859-1 Accept-Encoding： 表示客户端支持的内容编码格式。如：Accept-Encoding：gzip 常用的内容编码： gzip: 由文件压缩程序gzip生成的编码格式； compress: 由Unix文件压缩程序compress生成的编码格式； deflate: 组合使用zlib和deflate压缩算法生成的编码格式； identity：默认的编码格式，不执行压缩。 Accept-Language：表示客户端支持的语言。如：Accept-Language: zh-cn, en Authorization：表示客户端的认证信息。客户端在访问需要认证的也是时，服务器会返回401，随后客户端将认证信息 加在Authorization字段中发送到服务器后，如果认证成功，则返回200. 如Linux公社下的Ftp服务器就是这种流程： ftp://ftp1.linuxidc.com。 Host: 表示访问资源所在的主机名，即URL中的域名部分。如：m.baidu.com If-Match: If-Match的值与所请求资源的ETag值（实体标记，与资源相关联。资源变化，实体标记跟着变化）一致时， 服务器才处理此请求。 If-Modified-Since: 用于确认客户端拥有的本地资源的时效性。 如果客户端请求的资源在If-Modified-Since指定 的时间后发生了改变，则服务器处理该请求。如：If-Modified-Since:Thu 09 Jul 2018 00:00:00, 表示如果客户 端请求的资源在2018年1月9号0点之后发生了变化，则服务器处理改请求。通过该字段我们可解决以下问题：有一个包含大 量数据的接口，且实时性较高，我们在刷新时就可使用改字段，从而避免多余的流量消耗。 If-None-Match: If-Match的值与所请求资源的ETag值不一致时服务器才处理此请求。 If-Range： If-Range的值（ETag值或时间）与所访问资源的ETag值或时间相一致时，服务器处理此请求，并返回 Range字段中设置的指定范围的数据。如果不一致，则返回所有内容。If-Range其实算是If-Match的升级版，因为它 的值不匹配时，依然能够返回数据，而If-Match不匹配时，请求不会被处理，需要数据时需再次进行请求。 ​​ If-Unmodified-Since：与If-Modified-Since相反，表示请求的资源在指定的时间之后未发生变化时，才处理请求， ​ 否则返回412。 ​​ Max-Forwards：表示请求可经过的服务器的最大数目，请求每被转发一次，Max-Forwards减1，当Max-Forwards为0 ​ 时，所在的服务器将不再转发，而是直接做出应答。通过此字段可定位通信问题，比如之前支付宝光纤被挖断，就可通过设 ​ 置Max-Forwards来定位大概的位置。 ​ Proxy-Authorization：当客户端接收到来自代理服务器的认证质询时，客户端会将认证信息添加到 Proxy-Authorization来完成认证。与Authorization类似，只不过Authorization是发生在客户端与服务端之间。 Range：获取部分资源，例如：Range: bytes=500-1000表示获取指定资源的第500到1000字节之间的内容，如果服务器 能够正确处理，则返回206作为应答，表示返回了部分数据，如果不能处理这种范围请求，则以200作为应答，返回完整的 数据， Referer：告知服务器请求是从哪个页面发起的。例如在百度首页中搜索某个关键字，结果页面的请求头部就会有这个字段， 其值为https://www.baidu.com/。通过这个字段可统计广告的点击情况。 User-Agent：将发起请求的浏览器和代理名称等信息发送给服务端，例如： User-Agent: Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Mobile Safari/537.36 复制代码 应答报文字段 HTTP应答中支持的报文字段。 表示不能处理。 Age：服务端告知客户端，源服务器（而不是缓存服务器）在多久之前创建了响应。 单位为秒。 ETag： 实体资源的标识，可用来请求指定的资源。 Location：请求的资源所在的新位置。 Proxy-Authenticate：将代理服务器需要的认证信息发送给客户端。 Retry-After：服务端告知客户端多久之后再重试，一般与503和3xx重定向类型的应答一起使用。 Server：告知服务端当前使用的HTTP服务器应用程序的相关信息。 WWW-Authenticate：告知客户端适用于所访问资源的认证方案，如Basic或Digest。401的响应中肯定带有 WWW-Authenticate字段。 复制代码 实体首部字段 Allow：通知客户端，服务器所支持的请求方法。但服务器收到不支持的请求方法时，会以405（Method Not Allowed） 作为响应。 Content-Encoding：告知客户端，服务器对资源的内容编码。 Content-Language：告知客户端，资源所使用的自然语言。 Content-Length：告知客户端资源的长度 Content-Location：告知客户端资源所在的位置。 Content-Type：告知客户端资源的媒体类型，取值同请求首部字段中的Accept。 Expires：告知客户端资源的失效日期。可用于对缓存的处理。 Last-Modified：告知客户端资源最后一次修改的时间。 复制代码 通用报文字段 即可在HTTP请求中使用，也可在HTTP应答中使用的报文字段。 Cache-Control：控制缓存行为； Connection：管理持久连接，设置其值为Keep-Alive可实现长连接。 Date：创建HTTP报文的日期和时间。 Pragma：Http/1.1之前的历史遗留字段，仅作为HTTP/1.0向后兼容而定义，虽然是通用字段，当通常被使用在客户单的 请求中，如Pragma: no-cache, 表示客户端在请求过程中不循序服务端返回缓存的数据； Transfer-Encoding：规定了传输报文主题时使用的传输编码，如Transfer-Encoding: chunked Upgrade: 用于检查HTTP协议或其他协议是否有可使用的更高版本。 Via：追踪客户端和服务端之间的报文的传输路径，还可避免会环的发生，所以在经过代理时必须添加此字段。 Warning：Http/1.1的报文字段，从Http/1.0的AfterRetry演变而来，用来告知用户一些与缓存相关的警告信息。 复制代码 其他报文字段 这些字段不是HTTP协议中定义的，但被广泛应用于HTTP请求中。 Cookie：属于请求型报文字段，在请求时添加Cookie, 以实现HTTP的状态记录。 Set-Cookie：属于应答型报文字段。服务器给客户端传递Cookie信息时，就是通过此字段实现的。 Set-Cookie的字段属性： NAME=VALUE：赋予Cookie的名称和值； expires=DATE: Cookie的有效期； path=PATH: 将服务器上的目录作为Cookie的适用对象，若不指定，则默认为文档所在的文件目录； domin=域名：作为Cookies适用对象的域名，若不指定，则默认为创建Cookie的服务器域名； Secure: 仅在HTTPS安全通信是才会发送Cookie； HttpOnly: 使Cookie不能被JS脚本访问； 如：Set-Cookie:BDSVRBFE=Go; max-age=10; domain=m.baidu.com; path=/ 复制代码 HTTP应答状态码 状态码 类别 描述 1xx Informational(信息性状态码) 请求正在被处理 2xx Success(成功状态码) 请求处理成功 3xx Redirection(重定向状态码) 需要进行重定向 4xx Client Error(客户端状态码) 服务器无法处理请求 5xx Server Error(服务端状态码) 服务器处理请求时出错 常见应答状态码： 了解应答状态码的含义，有助于我们在开发过程中定位问题，比如出现4xx, 我们首先需要检查的是请求是否有问题，而出现5xx时，则应让服务端做相应的检查工作。 HTTP缺点 通信使用明文，可能被窃听 不验证通信方的身份，可能遭遇伪装 无法证明报文的完整性，有可能遭遇篡改 以上是HTTP的缺点，这在网络通信中对企业安全是很致命的问题。那HTTPS能解决这些问题吗？下面讲讲HTTPS。 HTTPS HTTP+加密+认证+完整性保护 = HTTPS HTTPS概念 引自维基百科HTTPS：超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。历史上，HTTPS连接经常用于万维网上的交易支付和企业信息系统中敏感信息的传输。在2000年代晚期和2010年代早期，HTTPS开始广泛使用于保护所有类型网站上的网页真实性，保护账户和保持用户通信，身份和网络浏览的私密性。 HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。 TLS/SSL全称安全传输层协议Transport Layer Security, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。 HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。HTTPS主要作用是： 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全 对网站服务器进行真实身份认证 HTTPS和HTTP的区别 可以看到HTTPS比HTTP多了一层TLS/SSL协议，这个协议是干嘛的，有什么作用呢？ 下面讲解TLS/SSL工作原理。 TLS/SSL工作原理 HTTPS协议的主要功能基本都依赖于TLS/SSL协议，TLS/SSL的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 散列函数Hash 常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性; 在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密; 对称加密 常见的有AES-CBC、DES、3DES、AES-GCM等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是1对1; 对称加密的优势是信息传输1对1，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和 N 个客户端通信，需要维持 N 个密码记录，且缺少修改密码的机制; 非对称加密 即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，服务器可以实现1对多的通信，客户端也可以用来验证掌握私钥的服务器身份。 非对称加密的特点是信息传输1对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。 结合三类算法的特点，TLS的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥， 然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。 PKI体系 RSA身份验证的隐患 身份验证和密钥协商是TLS的基础功能，要求的前提是合法的服务器掌握着对应的私钥。但RSA算法无法确保服务器身份的合法性，因为公钥并不包含服务器的信息，存在安全隐患: 客户端C和服务器S进行通信，中间节点M截获了二者的通信; 节点M自己计算产生一对公钥pub_M和私钥pri_M; C向S请求公钥时，M把自己的公钥pub_M发给了C; C使用公钥 pub_M加密的数据能够被M解密，因为M掌握对应的私钥pri_M，而 C无法根据公钥信息判断服务器的身份，从而 C和 * M之间建立了\"可信\"加密连接; 中间节点 M和服务器S之间再建立合法的连接，因此 C和 S之间通信被M完全掌握，M可以进行信息的窃听、篡改等操作。 另外，服务器也可以对自己的发出的信息进行否认，不承认相关信息是自己发出。 因此该方案下至少存在两类问题：中间人攻击和信息抵赖。 身份验证CA和证书 解决上述身份验证问题的关键是确保获取的公钥途径是合法的，能够验证服务器的身份信息，为此需要引入权威的第三方机构CA(如沃通CA)。CA 负责核实公钥的拥有者的信息，并颁发认证\"证书\"，同时能够为使用者提供证书验证服务，即PKI体系(PKI基础知识)。 基本的原理为，CA负责审核信息，然后对关键信息利用私钥进行\"签名\"，公开对应的公钥，客户端可以利用公钥验证签名。CA也可以吊销已经签发的证书，基本的方式包括两类 CRL 文件和 OCSP。CA使用具体的流程如下： a.服务方S向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证; b.CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等; c.如信息审核通过，CA会向申请者签发认证文件-证书。 证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名; 签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名; d.客户端 C 向服务器 S 发出请求时，S 返回证书文件; e.客户端 C读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法; f.客户端然后验证证书相关的域名信息、有效时间等信息; g.客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。 在这个过程注意几点： a.申请证书不需要提供私钥，确保私钥永远只能服务器掌握; b.证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名; c.内置 CA 对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书（为什么说\"部署自签SSL证书非常不安全\"） d.证书=公钥+申请者与颁发者信息+签名; 证书链 如 CA根证书和服务器证书中间增加一级证书机构，即中间证书，证书的产生和验证原理不变，只是增加一层验证，只要最后能够被任何信任的CA根证书验证合法即可。 a.服务器证书 server.pem 的签发者为中间证书机构 inter，inter 根据证书 inter.pem 验证 server.pem 确实为自己签发的有效证书; b.中间证书 inter.pem 的签发 CA 为 root，root 根据证书 root.pem 验证 inter.pem 为自己签发的合法证书; c.客户端内置信任 CA 的 root.pem 证书，因此服务器证书 server.pem 的被信任。 服务器证书、中间证书与根证书在一起组合成一条合法的证书链，证书链的验证是自下而上的信任传递的过程。 二级证书结构存在的优势： a.减少根证书结构的管理工作量，可以更高效的进行证书的审核与签发; b.根证书一般内置在客户端中，私钥一般离线存储，一旦私钥泄露，则吊销过程非常困难，无法及时补救; c.中间证书结构的私钥泄露，则可以快速在线吊销，并重新为用户签发新的证书; d.证书链四级以内一般不会对 HTTPS 的性能造成明显影响。 证书链有以下特点： a.同一本服务器证书可能存在多条合法的证书链。 因为证书的生成和验证基础是公钥和私钥对，如果采用相同的公钥和私钥生成不同的中间证书，针对被签发者而言，该签发机构都是合法的 CA，不同的是中间证书的签发机构不同; b.不同证书链的层级不一定相同，可能二级、三级或四级证书链。 中间证书的签发机构可能是根证书机构也可能是另一个中间证书机构，所以证书链层级不一定相同。 证书吊销 CA 机构能够签发证书，同样也存在机制宣布以往签发的证书无效。证书使用者不合法，CA 需要废弃该证书;或者私钥丢失，使用者申请让证书无效。主要存在两类机制：CRL 与 OCSP。 CRL Certificate Revocation List, 证书吊销列表(什么是证书吊销列表(CRL)？吊销列表起什么作用)，一个单独的文件。该文件包含了 CA 已经吊销的证书序列号(唯一)与吊销日期，同时该文件包含生效日期并通知下次更新该文件的时间，当然该文件必然包含 CA 私钥的签名以验证文件的合法性。 证书中一般会包含一个 URL 地址 CRL Distribution Point，通知使用者去哪里下载对应的 CRL 以校验证书是否吊销。该吊销方式的优点是不需要频繁更新，但是不能及时吊销证书，因为 CRL 更新时间一般是几天，这期间可能已经造成了极大损失。 OCSP Online Certificate Status Protocol, 证书状态在线查询协议，一个实时查询证书是否吊销的方式。请求者发送证书的信息并请求查询，服务器返回正常、吊销或未知中的任何一个状态。证书中一般也会包含一个 OCSP 的 URL 地址，要求查询服务器具有良好的性能。部分 CA 或大部分的自签 CA (根证书)都是未提供 CRL 或 OCSP 地址的，对于吊销证书会是一件非常麻烦的事情。 HTTPS性能与优化 HTTPS性能损耗 前文讨论了HTTPS原理与优势：身份验证、信息加密与完整性校验等，且未对TCP和HTTP协议做任何修改。但通过增加新协议以实现更安全的通信必然需要付出代价，HTTPS协议的性能损耗主要体现如下： 增加延时 分析前面的握手过程，一次完整的握手至少需要两端依次来回两次通信，至少增加延时2 RTT，利用会话缓存从而复用连接，延时也至少1 RTT* 消耗较多的CPU资源 除数据传输之外，HTTPS通信主要包括对对称加解密、非对称加解密(服务器主要采用私钥解密数据);压测 TS8 机型的单核 CPU：对称加密算法AES-CBC-256 吞吐量 600Mbps，非对称 RSA 私钥解密200次/s。不考虑其它软件层面的开销，10G 网卡为对称加密需要消耗 CPU 约17核，24核CPU最多接入 HTTPS 连接 4800; 静态节点当前10G 网卡的 TS8 机型的 HTTP 单机接入能力约为10w/s，如果将所有的HTTP连接变为HTTPS连接，则明显RSA的解密最先成为瓶颈。因此，RSA的解密能力是当前困扰HTTPS接入的主要难题。 HTTPS接入优化 CDN接入 HTTPS 增加的延时主要是传输延时 RTT，RTT 的特点是节点越近延时越小，CDN 天然离用户最近，因此选择使用 CDN 作为 HTTPS 接入的入口，将能够极大减少接入延时。CDN 节点通过和业务服务器维持长连接、会话复用和链路质量优化等可控方法，极大减少 HTTPS 带来的延时。 会话缓存 虽然前文提到 HTTPS 即使采用会话缓存也要至少1*RTT的延时，但是至少延时已经减少为原来的一半，明显的延时优化;同时，基于会话缓存建立的 HTTPS 连接不需要服务器使用RSA私钥解密获取 Pre-master 信息，可以省去CPU 的消耗。如果业务访问连接集中，缓存命中率高，则HTTPS的接入能力讲明显提升。当前TRP平台的缓存命中率高峰时期大于30%，10k/s的接入资源实际可以承载13k/的接入，收效非常可观。 硬件加速 为接入服务器安装专用的SSL硬件加速卡，作用类似 GPU，释放 CPU，能够具有更高的 HTTPS 接入能力且不影响业务程序的。测试某硬件加速卡单卡可以提供35k的解密能力，相当于175核 CPU，至少相当于7台24核的服务器，考虑到接入服务器其它程序的开销，一张硬件卡可以实现接近10台服务器的接入能力。 远程解密 本地接入消耗过多的 CPU 资源，浪费了网卡和硬盘等资源，考虑将最消耗 CPU 资源的RSA解密计算任务转移到其它服务器，如此则可以充分发挥服务器的接入能力，充分利用带宽与网卡资源。远程解密服务器可以选择 CPU 负载较低的机器充当，实现机器资源复用，也可以是专门优化的高计算性能的服务器。当前也是 CDN 用于大规模HTTPS接入的解决方案之一。 SPDY/HTTP2 前面的方法分别从减少传输延时和单机负载的方法提高 HTTPS 接入性能，但是方法都基于不改变 HTTP 协议的基础上提出的优化方法，SPDY/HTTP2 利用 TLS/SSL 带来的优势，通过修改协议的方法来提升 HTTPS 的性能，提高下载速度等。 Copyright © hanyajun.com all right reserved，powered by GitbookUpdated at 2019-06-30 17:40:06 "},"git/git.html":{"url":"git/git.html","title":"git操作整理","keywords":"","body":"git 操作整理 统一概念： - 工作区：改动（增删文件和内容） - 暂存区：输入命令：`git add 改动的文件名`，此次改动就放到了 ‘暂存区’ - 本地仓库(简称：本地)：输入命令：`git commit 此次修改的描述`，此次改动就放到了 ’本地仓库’，每个 commit，我叫它为一个 ‘版本’。 - 远程仓库(简称：远程)：输入命令：`git push 远程仓库`，此次改动就放到了 ‘远程仓库’（GitHub 等) - commit-id：输出命令：`git log`，最上面那行 `commit xxxxxx`，后面的字符串就是 commit-id 展示帮助信息 git help -g The command output as below: The common Git guides are: attributes Defining attributes per path cli Git command-line interface and conventions core-tutorial A Git core tutorial for developers cvs-migration Git for CVS users diffcore Tweaking diff output everyday A useful minimum set of commands for Everyday Git glossary A Git Glossary hooks Hooks used by Git ignore Specifies intentionally untracked files to ignore modules Defining submodule properties namespaces Git namespaces repository-layout Git Repository Layout revisions Specifying revisions and ranges for Git tutorial A tutorial introduction to Git tutorial-2 A tutorial introduction to Git: part two workflows An overview of recommended workflows with Git 'git help -a' and 'git help -g' list available subcommands and some concept guides. See 'git help ' or 'git help ' to read about a specific subcommand or concept. 回到远程仓库的状态 抛弃本地所有的修改，回到远程仓库的状态。 git fetch --all && git reset --hard origin/master 重设第一个 commit 也就是把所有的改动都重新放回工作区，并清空所有的 commit，这样就可以重新提交第一个 commit 了 git update-ref -d HEAD 展示工作区和暂存区的不同 输出工作区和暂存区的 different (不同)。 git diff 还可以展示本地仓库中任意两个 commit 之间的文件变动： git diff 展示暂存区和最近版本的不同 输出暂存区和本地最近的版本 (commit) 的 different (不同)。 git diff --cached 展示暂存区、工作区和最近版本的不同 输出工作区、暂存区 和本地最近的版本 (commit) 的 different (不同)。 git diff HEAD 快速切换到上一个分支 git checkout - 删除已经合并到 master 的分支 git branch --merged master | grep -v '^\\*\\| master' | xargs -n 1 git branch -d 展示本地分支关联远程仓库的情况 git branch -vv 关联远程分支 关联之后，git branch -vv 就可以展示关联的远程分支名了，同时推送到远程仓库直接：git push，不需要指定远程仓库了。 git branch -u origin/mybranch 或者在 push 时加上 -u 参数 git push origin/mybranch -u 列出所有远程分支 -r 参数相当于：remote git branch -r 列出本地和远程分支 -a 参数相当于：all git branch -a 查看远程分支和本地分支的对应关系 git remote show origin 远程删除了分支本地也想删除 git remote prune origin 创建并切换到本地分支 git checkout -b 从远程分支中创建并切换到本地分支 git checkout -b origin/ 删除本地分支 git branch -d 删除远程分支 git push origin --delete 或者 git push origin : 重命名本地分支 git branch -m 查看标签 git tag 展示当前分支的最近的 tag git describe --tags --abbrev=0 查看标签详细信息 git tag -ln 本地创建标签 git tag 默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag： $ git tag -a -m \"v1.0 发布(描述)\" 推送标签到远程仓库 首先要保证本地创建好了标签才可以推送标签到远程仓库： git push origin 一次性推送所有标签，同步到远程仓库： git push origin --tags 删除本地标签 git tag -d 删除远程标签 删除远程标签需要先删除本地标签，再执行下面的命令： git push origin :refs/tags/ 切回到某个标签 一般上线之前都会打 tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态： git checkout -b branch_name tag_name 放弃工作区的修改 git checkout 放弃所有修改： git checkout . 恢复删除的文件 git rev-list -n 1 HEAD -- #得到 deleting_commit git checkout ^ -- #回到删除文件 deleting_commit 之前的状态 以新增一个 commit 的方式还原某一个 commit 的修改 git revert 回到某个 commit 的状态，并删除后面的 commit 和 revert 的区别：reset 命令会抹去某个 commit id 之后的所有 commit git reset #默认就是-mixed参数。 git reset –mixed HEAD^ #回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。 git reset –soft HEAD~3 #回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可 git reset –hard #彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容 修改上一个 commit 的描述 如果暂存区有改动，同时也会将暂存区的改动提交到上一个 commit git commit --amend 查看 commit 历史 git log 查看某段代码是谁写的 blame 的意思为‘责怪’，你懂的。 git blame 显示本地更新过 HEAD 的 git 命令记录 每次更新了 HEAD 的 git 命令比如 commint、amend、cherry-pick、reset、revert 等都会被记录下来（不限分支），就像 shell 的 history 一样。 这样你可以 reset 到任何一次更新了 HEAD 的操作之后，而不仅仅是回到当前分支下的某个 commit 之后的状态。 git reflog 修改作者名 git commit --amend --author='Author Name ' 修改远程仓库的 url git remote set-url origin 增加远程仓库 git remote add origin 列出所有远程仓库 git remote 查看两个星期内的改动 git whatchanged --since='2 weeks ago' 把 A 分支的某一个 commit，放到 B 分支上 这个过程需要 cherry-pick 命令，参考 git checkout && git cherry-pick 给 git 命令起别名 简化命令 git config --global alias. 比如：git status 改成 git st，这样可以简化命令 git config --global alias.st status 存储当前的修改，但不用提交 commit 详解可以参考廖雪峰老师的 git 教程 git stash 保存当前状态，包括 untracked 的文件 untracked 文件：新建的文件 git stash -u 展示所有 stashes git stash list 回到某个 stash 的状态 git stash apply 回到最后一个 stash 的状态，并删除这个 stash git stash pop 删除所有的 stash git stash clear 从 stash 中拿出某个文件的修改 git checkout -- 展示所有 tracked 的文件 git ls-files -t 展示所有 untracked 的文件 git ls-files --others 展示所有忽略的文件 git ls-files --others -i --exclude-standard 强制删除 untracked 的文件 可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的 untracked 文件。clean 命令，注意两点： clean 后，删除的文件无法找回 不会影响 tracked 的文件的改动，只会删除 untracked 的文件 git clean -f 强制删除 untracked 的目录 可以用来删除新建的目录，注意:这个命令也可以用来删除 untracked 的文件。详情见上一条 git clean -df 展示简化的 commit 历史 git log --pretty=oneline --graph --decorate --all 把某一个分支到导出成一个文件 git bundle create 从包中导入分支 新建一个分支，分支内容就是上面 git bundle create 命令导出的内容 git clone repo.bundle -b 执行 rebase 之前自动 stash git rebase --autostash 从远程仓库根据 ID，拉下某一状态，到本地分支 git fetch origin pull//head: 详细展示一行中的修改 git diff --word-diff 清除 gitignore 文件中记录的文件 git clean -X -f 展示所有 alias 和 configs 注意： config 分为：当前目录（local）和全局（golbal）的 config，默认为当前目录的 config git config --local --list (当前目录) git config --global --list (全局) 展示忽略的文件 git status --ignored commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit git log Branch1 ^Branch2 在 commit log 中显示 GPG 签名 git log --show-signature 删除全局设置 git config --global --unset 新建并切换到新分支上，同时这个分支没有任何 commit 相当于保存修改，但是重写 commit 历史 git checkout --orphan 展示任意分支某一文件的内容 git show : clone 下来指定的单一分支 git clone -b --single-branch https://github.com/user/repo.git clone 最新一次提交 只会 clone 最近一次提交，将减少 clone 时间 git clone --depth=1 https://github.com/user/repo.git 忽略某个文件的改动 关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动 git update-index --assume-unchanged path/to/file 恢复 track 指定文件的改动 git update-index --no-assume-unchanged path/to/file 忽略文件的权限变化 不再将文件的权限变化视作改动 git config core.fileMode false 以最后提交的顺序列出所有 Git 分支 最新的放在最上面 git for-each-ref --sort=-committerdate --format='%(refname:short)' refs/heads/ 在 commit log 中查找相关内容 通过 grep 查找，given-text：所需要查找的字段 git log --all --grep='' 把暂存区的指定 file 放到工作区中 不添加参数，默认是 -mixed git reset 强制推送 git push -f git 配置 http 和 socks 代理 git config --global https.proxy 'http://127.0.0.1:8001' # 适用于 privoxy 将 socks 协议转为 http 协议的 http 端口 git config --global http.proxy 'http://127.0.0.1:8001' git config --global socks.proxy \"127.0.0.1:1080\" git 配置 ssh 代理 $ cat ~/.ssh/config Host gitlab.com ProxyCommand nc -X 5 -x 127.0.0.1:1080 %h %p # 直接使用 shadowsocks 提供的 socks5 代理端口 Host github.com ProxyCommand nc -X 5 -x 127.0.0.1:1080 %h %p 一图详解 优雅的提交Commit信息 使用Angular团队提交规范 主要有以下组成 标题行: 必填, 描述主要修改类型和内容 主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等等 页脚注释: 放 Breaking Changes 或 Closed Issues 常用的修改项 type: commit 的类型 feat: 新特性 fix: 修改问题 refactor: 代码重构 docs: 文档修改 style: 代码格式修改, 注意不是 css 修改 test: 测试用例修改 chore: 其他修改, 比如构建流程, 依赖管理. scope: commit 影响的范围, 比如: route, component, utils, build... subject: commit 的概述 body: commit 具体修改内容, 可以分为多行 footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接. 使用Commitizen代替 git commit 可以使用cz-cli工具代替 git commit 全局安装 npm install -g commitizen cz-conventional-changelog echo '{ \"path\": \"cz-conventional-changelog\" }' > ~/.czrc 全局安装后使用 git cz 代替 git commit就可以了,如下图 参考文章：https://github.com/521xueweihan/git-tips Copyright © hanyajun.com all right reserved，powered by GitbookUpdated at 2019-06-15 22:53:52 "}}